name: Update Staging Database

on:
  workflow_dispatch:

# on:
#   schedule:
#     - cron: '0 0 * * *'  # Runs at 00:00 UTC daily.

jobs:
  backup_upload:
    runs-on: ubuntu-latest
    environment: staging
    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/private_key.pem
          chmod 600 ~/.ssh/private_key.pem
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Update from backup
        run: |
          echo "Authenticating with GCP."
          echo '${{ secrets.GCP_SA_KEY }}' > /tmp/gcp-sa-key.json
          gcloud auth activate-service-account --key-file=/tmp/gcp-sa-key.json
          rm /tmp/gcp-sa-key.json $BACKUP_NAME

          BACKUP=$(gsutil ls -l gs://ocho-osai/track/pg_data/ | grep -v "TOTAL:" | sort -k2,2 -r | awk '{ $1=$2=""; print $0 }' | sed 's/^[ \t]*//' | head -n 1 | tr -d '\n')
          BACKUP_NAME=$(basename $BACKUP)
          BACKUP_FILE="backups/$BACKUP_NAME"
          mkdir -p ./track/backups/
          gsutil cp $BACKUP $BACKUP_FILE
          echo "Most recent backup found: $BACKUP_NAME"

          # Check if the backup file exists and is a gzip file
          if [ -f "$BACKUP_FILE" ] && [[ $BACKUP_FILE == *.gz ]]; then
              echo "Decompressing backup file $BACKUP_FILE"
              gunzip -k "$BACKUP_FILE"
              BACKUP_FILE="${BACKUP_FILE%.gz}"
              echo "Backup decompressed to $BACKUP_FILE"
          else
              echo "Backup file does not exist or is not a gzip file."
              exit 1
          fi

          ssh -i ~/.ssh/private_key.pem ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << ENDSSH
            echo "Removing old backups."
            rm -r /home/${{ secrets.SERVER_USER }}/track/backups/ || true
            mkdir -p /home/${{ secrets.SERVER_USER }}/track/backups/
          ENDSSH

          scp -i ~/.ssh/private_key.pem $BACKUP_FILE ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/home/${{ secrets.SERVER_USER }}/track/$BACKUP_FILE
          ssh -i ~/.ssh/private_key.pem ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << ENDSSH
            echo "Restoring from backup: ./track/$BACKUP_FILE"
            ls ./track/backups/

            export APP_ENV=${{ vars.APP_ENV }}
            export HOST_PORT=${{ vars.HOST_PORT }}
            export POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}

            # Restore from backup. The postgres docker service is called "db"
            echo "Bringing down services."
            docker compose -f track/base.yml -f track/prod.yml down

            # echo "Starting db service in isolation."
            # docker compose -f track/base.yml -f track/prod.yml up -d db

            # echo "Preparing for restore."
            # docker compose -f track/base.yml -f track/prod.yml exec db psql -U postgres -c "DROP DATABASE IF EXISTS trackdb;"
            # docker compose -f track/base.yml -f track/prod.yml exec db psql -U postgres -c "CREATE DATABASE trackdb;"

            # echo "Restoring from backup."
            # docker compose -f track/base.yml -f track/prod.yml cp ./track/$BACKUP_FILE db:/backup
            # docker compose -f track/base.yml -f track/prod.yml exec db psql -U postgres -d trackdb -f /backup

            # echo "Bringing down db."
            # docker compose -f track/base.yml -f track/prod.yml down

            # echo "Bringing up all services."
            # docker compose -f track/base.yml -f track/prod.yml up -d

            # echo "Status:"
            # docker compose -f track/base.yml -f track/prod.yml ps

            echo "Starting db service in isolation."
            docker compose -f track/base.yml -f track/prod.yml up -d db || { echo "Failed to start db service"; exit 1; }

            echo "Waiting for database to initialize..."
            sleep 3  # Wait to ensure db is up. Adjust time as needed.

            echo "Preparing for restore."
            docker compose -f track/base.yml -f track/prod.yml exec db psql -U postgres -c "DROP DATABASE IF EXISTS trackdb;" || { echo "Failed to drop database"; exit 1; }
            sleep 1
            docker compose -f track/base.yml -f track/prod.yml exec db psql -U postgres -c "CREATE DATABASE trackdb;" || { echo "Failed to create database"; exit 1; }

            echo "Waiting for new database to be ready..."
            sleep 3  # Wait for a few seconds. Adjust time as needed.

            echo "Restoring from backup."
            docker compose -f track/base.yml -f track/prod.yml cp ./track/$BACKUP_FILE db:/backup || { echo "Failed to copy backup file"; exit 1; }
            docker compose -f track/base.yml -f track/prod.yml exec db psql -U postgres -d trackdb -f /backup || { echo "Failed to restore database from backup"; exit 1; }

            sleep 3  # Wait for a few seconds. Adjust time as needed.
            echo "Bringing down db."
            docker compose -f track/base.yml -f track/prod.yml down || { echo "Failed to bring down db"; exit 1; }

            echo "Bringing up all services."
            docker compose -f track/base.yml -f track/prod.yml up -d || { echo "Failed to bring up all services"; exit 1; }

            echo "Status:"
            docker compose -f track/base.yml -f track/prod.yml ps


          ENDSSH
